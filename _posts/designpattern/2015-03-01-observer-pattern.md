---
layout: post
title: "第二章：观察者模式 - Head First 设计模式"
categories:
- 设计模式
tag: [设计模式]
---

## 观察者模式

##### `观察者模式`定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

##### 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。

##### 程序的正确性不应该依赖于观察者被通知的顺序。

##### 模式类图：p52

##### 典型应用：

1. 许多GUI框架大量使用观察者模式，比如Swing API，JButton的事件绑定，jbutton.addActionListener(...).
2. 此模式也被用着许多地方，比如JavaBeans,RMI.

### 例子：气象监测应用

#### 不好的设计1：p42代码

1. 针对具体实现编程，这会导致以后增删布告板时需要修改代码。
2. 如果以后增删监测项，连方法参数都要改。
3. 不能做到在运行时动态增删布告板。

#### 观察者模式的设计1：自己实现p56

#### 观察者模式的设计2：java内置p64


### java内置的观察者模式:p64

代码示例：p67

*PS：在调用notifyObservers(...)前要调用setChanged()来标记状态已改变。*

#### java.util.Observable的黑暗面

1. Observable是一个类，导致子类不能再继承别的类了。
2. Observable的setChanged()是protected修饰的，这意味着，你不能创建Observable实例组合到你自己的对象中(除非继承自Observable)。


## 设计原则

#### 设计原则4：为了交互对象之间的松耦合设计而努力。

松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的依赖降到了最低。





------------
#### 不好的设计1：p4图

![p4图](/images/design-pattern/p4.png)

1. 如果想只给部分类型的鸭子增加fly()将会非常麻烦。

#### 不好的设计2：p6图

![p6图](/images/design-pattern/p6.png)

1. 如果多个类型的鸭子的fly()行为一样，那么将会出现很多重复代码。
2. 如果要修改所有鸭子的fly()行为，那么需要修改很多地方。

#### 策略模式的设计：p22图

![p22图](/images/design-pattern/p22.png)

## 设计原则

在软件开发上，有什么是你可以深信不疑的？
改变！不管当初软件设计得多好，一段时间过后，总是需要成长与改变。

##### 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

把会变化的部分取出并封装起来，会使得系统更有弹性。

##### 设计原则2：针对接口编程，而不是针对实现编程。

这里的"接口"是广义的"接口"，真正的意思是"针对超类型(supertype)编程"。

##### 设计原则3：多用组合，少用继承。

使用组合建立系统具有很大弹性， 
1.不仅可将算法簇封装成类，
2.更可以"在运行时动态地改变行为"(只要组合的行为对象符合正确的接口标准即可)。




